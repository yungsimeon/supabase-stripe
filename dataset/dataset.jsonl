{"id":"supabase/rls/organization_members/conflict-self-ref@2025-10-21","provider":"supabase","doc_type":"blueprint-fix","tags":["supabase","postgres","rls","security","auth","org-memberships"],"summary":{"embedding_text":"Fix duplicate and self-referencing RLS on organization_members that causes infinite recursion and ambiguous access. Replace overlapping policies with a single consolidated SELECT policy that uses a SECURITY DEFINER membership check to avoid self-recursion. Also remove conflicting allow-all on organizations."},"context":{"table":"public.organization_members","symptoms":["Infinite recursion in policy for relation \"organization_members\" during SELECT","Ambiguous/duplicated policies produce unexpected access paths"],"observed_error":"Failed to fetch user organizations: infinite recursion detected in policy for relation \"organization_members\"","calling_code_excerpt":"supabase.from(\"organization_members\").select(\"role, organization_id, organizations!inner(...)\").eq(\"user_id\", userId)"},"bad_policies":[{"name":"Users can view members of organizations they belong to","for":"SELECT","sql":"CREATE POLICY \"Users can view members of organizations they belong to\" ON organization_members FOR SELECT USING (EXISTS (SELECT 1 FROM organization_members om WHERE om.organization_id = organization_members.organization_id AND om.user_id = auth.uid()));","why_bad":"Self-references organization_members inside its own policy ‚Üí recursive policy evaluation."},{"name":"organization_members_own_only","for":"SELECT","sql":"CREATE POLICY \"organization_members_own_only\" ON organization_members FOR SELECT USING (user_id = auth.uid());","why_bad":"Duplicates the 'own memberships' intent; overlapping SELECT policies make behavior harder to reason about."},{"name":"Service role can manage all memberships","for":"ALL","sql":"CREATE POLICY \"Service role can manage all memberships\" ON organization_members FOR ALL USING (auth.role() = 'service_role');","why_bad":"Not inherently bad; keep as explicit server-side override."}],"related_issues":[{"table":"public.organizations","policy":"organizations_allow_all","sql":"CREATE POLICY \"organizations_allow_all\" ON organizations FOR ALL USING (true);","why_bad":"Overrides restrictive SELECT policy ('Users can view organizations they are members of'). Enables broad unintended access."}],"good_pattern":{"title":"Consolidated, non-recursive RLS using SECURITY DEFINER helper","helper_fn_sql":"CREATE OR REPLACE FUNCTION public.is_member_of(org_id uuid, uid uuid)\nRETURNS boolean\nLANGUAGE sql\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.organization_members m\n    WHERE m.organization_id = org_id\n      AND m.user_id = uid\n  );\n$$;","consolidated_policy_sql":"ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;\nDROP POLICY IF EXISTS \"Users can view members of organizations they belong to\" ON public.organization_members;\nDROP POLICY IF EXISTS \"organization_members_own_only\" ON public.organization_members;\nDROP POLICY IF EXISTS \"Service role can manage all memberships\" ON public.organization_members;\nCREATE POLICY \"service role can manage all\" ON public.organization_members FOR ALL USING (auth.role() = 'service_role');\nCREATE POLICY \"org_members_read\" ON public.organization_members FOR SELECT USING (auth.role() = 'service_role' OR user_id = auth.uid() OR public.is_member_of(organization_id, auth.uid()));","organizations_fix_sql":"DROP POLICY IF EXISTS \"organizations_allow_all\" ON public.organizations;\nCREATE POLICY \"orgs_read_members_only\" ON public.organizations FOR SELECT USING (public.is_member_of(id, auth.uid()) OR auth.role() = 'service_role');","why_good":["Avoids self-referencing the protected table inside its own policy.","One SELECT policy ‚Üí predictable behavior and easier audits.","SERVICE ROLE carve-out remains explicit.","Organizations visibility aligns with membership helper; no 'allow all'."]},"migration_steps":["1) Create SECURITY DEFINER function public.is_member_of(org_id, uid) owned by the table owner.","2) DROP the self-referencing and duplicate SELECT policies on organization_members.","3) (Re)create a single consolidated SELECT policy using is_member_of(...) + keep service-role policy.","4) DROP 'organizations_allow_all' and replace with a membership-based SELECT policy.","5) Verify with canary queries (see below)."],"canary_tests":[{"name":"Self user can select only their own memberships","sql":"SET ROLE authenticated; SELECT count(*) FROM public.organization_members WHERE user_id = auth.uid();","expect":"succeeds; returns only rows for current user"},{"name":"Member can see other members of same org (via join, not recursion)","sql":"SELECT count(*) FROM public.organization_members m2 WHERE m2.organization_id IN (SELECT organization_id FROM public.organization_members WHERE user_id = auth.uid());","expect":"succeeds; no recursion error"},{"name":"Non-member cannot see other org memberships","sql":"SELECT * FROM public.organization_members WHERE organization_id = 'some_other_org';","expect":"returns zero rows"},{"name":"Organizations SELECT restricted","sql":"SELECT * FROM public.organizations;","expect":"returns only organizations where user is a member (unless service_role)"}],"lint_rules":[{"id":"rls-self-reference","description":"Detect policies that SELECT from the same table they protect.","pattern":"USING contains subquery referencing current table name","severity":"error","suggestion":"Move membership logic into a SECURITY DEFINER helper and call it in the policy."},{"id":"rls-duplicate-select","description":"Multiple SELECT policies with overlapping predicates on same table.","severity":"warn","suggestion":"Consolidate into a single SELECT policy with clear OR conditions."},{"id":"rls-allow-all-shadow","description":"Detect FOR ALL/SELECT USING(true) on sensitive tables that shadow restrictive policies.","severity":"error","suggestion":"Remove allow-all or guard behind service_role only."}],"artifacts":{"sql_apply_ordered":["<<helper_fn_sql>>","<<consolidated_policy_sql>>","<<organizations_fix_sql>>"],"notes":"Ensure the helper function owner is a role exempt from RLS (table owner). In Supabase, functions run with their owner privileges when SECURITY DEFINER is set, avoiding recursion."}}
{"id":"supabase/auth/magic-link/timing-issue@2025-01-27","provider":"supabase","doc_type":"blueprint-fix","tags":["supabase","auth","magic-link","nextjs","timing","session","middleware","redirect"],"summary":{"embedding_text":"Fix magic link authentication timing issue where immediate redirect causes session not to be established before middleware check. Use auth state change listener to wait for SIGNED_IN event before redirecting to dashboard. Critical: Supabase magic link auth is asynchronous - session establishment takes time."},"context":{"framework":"Next.js App Router with Supabase SSR","version":"Next.js 15, Supabase Auth v2","symptoms":["Magic link clicked but user shows as 'Not authenticated' in middleware","Immediate redirect to dashboard fails with session not established","Works when manually accessing dashboard after magic link","Middleware logs show: 'User: Not authenticated' then later 'User: email@domain.com'","Browser console shows: 'Auth confirm params: { code: \"...\", tokenHash: null, type: null }'"],"observed_error":"AuthApiError: invalid request: both auth code and code verifier should be non-empty","calling_code_excerpt":"// In /auth/confirm page\nif (code) {\n  router.push('/dashboard'); // ‚ùå Called immediately\n}","debugging_logs":{"middleware_logs":"üîê Middleware - Path: /auth/confirm\nüë§ User: Not authenticated\nüîê Middleware - Path: /dashboard\nüë§ User: Not authenticated\nüö´ Redirecting to login - no user on protected route: /dashboard","browser_console":"üîó Auth confirm params: { code: \"55166e45-81f6-4d62-a98b-822565069d6f\", tokenHash: null, type: null, errorParam: null, errorDescription: null }","success_logs":"üîê Middleware - Path: /dashboard\nüë§ User: simon@hydraoss.io (f1ceefc0-bd0b-49ca-9101-86b4bcff0d4a)\nüìä User metadata: { email: 'simon@hydraoss.io', email_verified: true, ... }"},"root_cause":"Magic link authentication in Supabase is asynchronous. When the magic link is clicked, the session is established server-side, but the client-side JavaScript needs to wait for the auth state change event to know when the session is ready. Immediate redirects happen before the session is established."},"bad_patterns":[{"name":"Immediate redirect after magic link","code":"//  BAD: Immediate redirect\nif (code) {\n  console.log('üîê Magic link detected, redirecting to dashboard...');\n  router.push('/dashboard'); // Session not established yet\n}","why_bad":"Magic link authentication is asynchronous - session takes time to establish. This causes the middleware to see 'Not authenticated' and redirect to login."},{"name":"PKCE code exchange without verifier","code":"// BAD: Missing code verifier\nconst { data, error } = await supabase.auth.exchangeCodeForSession(code);\n// Fails with: 'both auth code and code verifier should be non-empty'","why_bad":"PKCE flow requires code verifier parameter, but magic links don't provide one in the URL."},{"name":"Wrong session structure access","code":"// ‚ùå BAD: Wrong session structure\nif (sessionData.user) { // Should be sessionData.session.user\n  router.push('/dashboard');\n}","why_bad":"Supabase session object has nested structure: sessionData.session.user, not sessionData.user directly."}],"good_pattern":{"title":"Auth state change listener with proper session handling","listener_code":"// ‚úÖ GOOD: Listen for auth state changes\nif (code) {\n  console.log('üîê Magic link detected, setting up auth listener...');\n  \n  // Listen for auth state changes\n  const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {\n    console.log('üîê Auth state change:', event, session?.user?.email);\n    \n    if (event === 'SIGNED_IN' && session?.user) {\n      console.log('‚úÖ User signed in:', session.user.email);\n      router.push('/dashboard');\n      subscription.unsubscribe();\n    }\n  });\n  \n  // Also check for existing session\n  const { data: sessionData } = await supabase.auth.getSession();\n  if (sessionData.session && sessionData.session.user) {\n    console.log('‚úÖ Session already exists:', sessionData.session.user.email);\n    router.push('/dashboard');\n    subscription.unsubscribe();\n  }\n}","session_check_code":"// ‚úÖ GOOD: Check existing session with correct structure\nconst { data: sessionData } = await supabase.auth.getSession();\nif (sessionData.session && sessionData.session.user) {\n  console.log('‚úÖ Session already exists:', sessionData.session.user.email);\n  router.push('/dashboard');\n  subscription.unsubscribe();\n}","why_good":["Waits for actual authentication event (SIGNED_IN)","Handles both new and existing sessions","Proper cleanup with unsubscribe to prevent memory leaks","No PKCE complications - uses auth state listener instead","Correct session structure: sessionData.session.user"]},"migration_steps":["1) Replace immediate redirect with auth state listener","2) Add session check for already authenticated users","3) Use proper session structure (sessionData.session.user not sessionData.user)","4) Clean up listener subscription when done","5) Test magic link flow end-to-end","6) Add console logging to debug auth state changes","7) Verify middleware logs show authenticated user"],"canary_tests":[{"name":"Magic link establishes session","test":"Click magic link and check middleware logs","expect":"User shows as authenticated in middleware: 'üë§ User: email@domain.com (uuid)'"},{"name":"Auth state listener fires","test":"Check browser console for SIGNED_IN event","expect":"Console shows 'üîê Auth state change: SIGNED_IN email@domain.com'"},{"name":"Redirect happens after session","test":"Verify redirect to dashboard only after authentication","expect":"No intermediate redirect to login page"},{"name":"Session structure is correct","test":"Check that sessionData.session.user exists","expect":"No 'user' property in session type errors"}],"lint_rules":[{"id":"auth-immediate-redirect","description":"Avoid immediate redirects after auth actions that are asynchronous.","pattern":"router.push() called immediately after auth method","severity":"error","suggestion":"Use auth state change listener or add delay"},{"id":"auth-session-structure","description":"Use correct session object structure in Supabase.","pattern":"sessionData.user instead of sessionData.session.user","severity":"error","suggestion":"Access user via sessionData.session.user"},{"id":"auth-listener-cleanup","description":"Always unsubscribe from auth state change listeners.","pattern":"onAuthStateChange without unsubscribe","severity":"warn","suggestion":"Call subscription.unsubscribe() when done"},{"id":"auth-magic-link-timing","description":"Magic link authentication is asynchronous - wait for SIGNED_IN event.","pattern":"Magic link redirect without auth state listener","severity":"error","suggestion":"Use onAuthStateChange listener to wait for SIGNED_IN event"}],"artifacts":{"code_apply_ordered":["<<listener_code>>","<<session_check_code>>"],"notes":"Magic link authentication in Supabase is asynchronous. The session is established server-side when the link is clicked, but the client needs to wait for the auth state change event to know when it's ready. The key insight is that middleware runs immediately but the session takes time to establish, causing the 'Not authenticated' ‚Üí redirect to login ‚Üí then later 'authenticated' pattern."}}
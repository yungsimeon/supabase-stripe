[
  {
    "id": "supabase\/rls\/organization_members\/conflict-self-ref@2025-10-21",
    "provider": "supabase",
    "doc_type": "blueprint-fix",
    "tags": [
      "supabase",
      "postgres",
      "rls",
      "security",
      "auth",
      "org-memberships"
    ],
    "summary": "Fix duplicate and self-referencing RLS on organization_members that causes infinite recursion and ambiguous access. Replace overlapping policies with a single consolidated SELECT policy that uses a SECURITY DEFINER membership check to avoid self-recursion. Also remove conflicting allow-all on organizations.",
    "context": {
      "table": "public.organization_members",
      "symptoms": [
        "Infinite recursion in policy for relation \"organization_members\" during SELECT",
        "Ambiguous\/duplicated policies produce unexpected access paths"
      ],
      "observed_error": "Failed to fetch user organizations: infinite recursion detected in policy for relation \"organization_members\"",
      "calling_code_excerpt": "supabase.from(\"organization_members\").select(\"role, organization_id, organizations!inner(...)\").eq(\"user_id\", userId)"
    },
    "bad_policies": [
      {
        "name": "Users can view members of organizations they belong to",
        "for": "SELECT",
        "sql": "CREATE POLICY \"Users can view members of organizations they belong to\" ON organization_members FOR SELECT USING (EXISTS (SELECT 1 FROM organization_members om WHERE om.organization_id = organization_members.organization_id AND om.user_id = auth.uid()));",
        "why_bad": "Self-references organization_members inside its own policy \u2192 recursive policy evaluation."
      },
      {
        "name": "organization_members_own_only",
        "for": "SELECT",
        "sql": "CREATE POLICY \"organization_members_own_only\" ON organization_members FOR SELECT USING (user_id = auth.uid());",
        "why_bad": "Duplicates the 'own memberships' intent; overlapping SELECT policies make behavior harder to reason about."
      },
      {
        "name": "Service role can manage all memberships",
        "for": "ALL",
        "sql": "CREATE POLICY \"Service role can manage all memberships\" ON organization_members FOR ALL USING (auth.role() = 'service_role');",
        "why_bad": "Not inherently bad; keep as explicit server-side override."
      }
    ],
    "related_issues": [
      {
        "table": "public.organizations",
        "policy": "organizations_allow_all",
        "sql": "CREATE POLICY \"organizations_allow_all\" ON organizations FOR ALL USING (true);",
        "why_bad": "Overrides restrictive SELECT policy ('Users can view organizations they are members of'). Enables broad unintended access."
      }
    ],
    "good_pattern": {
      "title": "Consolidated, non-recursive RLS using SECURITY DEFINER helper",
      "helper_fn_sql": "CREATE OR REPLACE FUNCTION public.is_member_of(org_id uuid, uid uuid)\nRETURNS boolean\nLANGUAGE sql\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.organization_members m\n    WHERE m.organization_id = org_id\n      AND m.user_id = uid\n  );\n$$;",
      "consolidated_policy_sql": "ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;\nDROP POLICY IF EXISTS \"Users can view members of organizations they belong to\" ON public.organization_members;\nDROP POLICY IF EXISTS \"organization_members_own_only\" ON public.organization_members;\nDROP POLICY IF EXISTS \"Service role can manage all memberships\" ON public.organization_members;\nCREATE POLICY \"service role can manage all\" ON public.organization_members FOR ALL USING (auth.role() = 'service_role');\nCREATE POLICY \"org_members_read\" ON public.organization_members FOR SELECT USING (auth.role() = 'service_role' OR user_id = auth.uid() OR public.is_member_of(organization_id, auth.uid()));",
      "organizations_fix_sql": "DROP POLICY IF EXISTS \"organizations_allow_all\" ON public.organizations;\nCREATE POLICY \"orgs_read_members_only\" ON public.organizations FOR SELECT USING (public.is_member_of(id, auth.uid()) OR auth.role() = 'service_role');",
      "why_good": [
        "Avoids self-referencing the protected table inside its own policy.",
        "One SELECT policy \u2192 predictable behavior and easier audits.",
        "SERVICE ROLE carve-out remains explicit.",
        "Organizations visibility aligns with membership helper; no 'allow all'."
      ]
    },
    "migration_steps": [
      "1) Create SECURITY DEFINER function public.is_member_of(org_id, uid) owned by the table owner.",
      "2) DROP the self-referencing and duplicate SELECT policies on organization_members.",
      "3) (Re)create a single consolidated SELECT policy using is_member_of(...) + keep service-role policy.",
      "4) DROP 'organizations_allow_all' and replace with a membership-based SELECT policy.",
      "5) Verify with canary queries (see below)."
    ],
    "canary_tests": [
      {
        "name": "Self user can select only their own memberships",
        "sql": "SET ROLE authenticated; SELECT count(*) FROM public.organization_members WHERE user_id = auth.uid();",
        "expect": "succeeds; returns only rows for current user"
      },
      {
        "name": "Member can see other members of same org (via join, not recursion)",
        "sql": "SELECT count(*) FROM public.organization_members m2 WHERE m2.organization_id IN (SELECT organization_id FROM public.organization_members WHERE user_id = auth.uid());",
        "expect": "succeeds; no recursion error"
      },
      {
        "name": "Non-member cannot see other org memberships",
        "sql": "SELECT * FROM public.organization_members WHERE organization_id = 'some_other_org';",
        "expect": "returns zero rows"
      },
      {
        "name": "Organizations SELECT restricted",
        "sql": "SELECT * FROM public.organizations;",
        "expect": "returns only organizations where user is a member (unless service_role)"
      }
    ],
    "lint_rules": [
      {
        "id": "rls-self-reference",
        "description": "Detect policies that SELECT from the same table they protect.",
        "pattern": "USING contains subquery referencing current table name",
        "severity": "error",
        "suggestion": "Move membership logic into a SECURITY DEFINER helper and call it in the policy."
      },
      {
        "id": "rls-duplicate-select",
        "description": "Multiple SELECT policies with overlapping predicates on same table.",
        "severity": "warn",
        "suggestion": "Consolidate into a single SELECT policy with clear OR conditions."
      },
      {
        "id": "rls-allow-all-shadow",
        "description": "Detect FOR ALL\/SELECT USING(true) on sensitive tables that shadow restrictive policies.",
        "severity": "error",
        "suggestion": "Remove allow-all or guard behind service_role only."
      }
    ],
    "artifacts": {
      "sql_apply_ordered": [
        "<<helper_fn_sql>>",
        "<<consolidated_policy_sql>>",
        "<<organizations_fix_sql>>"
      ],
      "notes": "Ensure the helper function owner is a role exempt from RLS (table owner). In Supabase, functions run with their owner privileges when SECURITY DEFINER is set, avoiding recursion."
    },
    "raw_for_debug": "id: supabase\/rls\/organization_members\/conflict-self-ref@2025-10-21\nprovider: supabase\ndoc_type: blueprint-fix\ntags: supabase,postgres,rls,security,auth,org-memberships\nsummary: Fix duplicate and self-referencing RLS on organization_members that causes infinite recursion and ambiguous access. Replace overlapping policies with a single consolidated SELECT policy that uses a SECURITY DEFINER membership check to avoid self-recursion. Also remove conflicting allow-all on organizations.\ntable: public...."
  }
]
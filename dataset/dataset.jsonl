{"id":"supabase/rls/organization_members/conflict-self-ref@2025-10-21","provider":"supabase","doc_type":"blueprint-fix","tags":["supabase","postgres","rls","security","auth","org-memberships"],"summary":{"embedding_text":"Fix duplicate and self-referencing RLS on organization_members that causes infinite recursion and ambiguous access. Replace overlapping policies with a single consolidated SELECT policy that uses a SECURITY DEFINER membership check to avoid self-recursion. Also remove conflicting allow-all on organizations."},"context":{"table":"public.organization_members","symptoms":["Infinite recursion in policy for relation \"organization_members\" during SELECT","Ambiguous/duplicated policies produce unexpected access paths"],"observed_error":"Failed to fetch user organizations: infinite recursion detected in policy for relation \"organization_members\"","calling_code_excerpt":"supabase.from(\"organization_members\").select(\"role, organization_id, organizations!inner(...)\").eq(\"user_id\", userId)"},"bad_policies":[{"name":"Users can view members of organizations they belong to","for":"SELECT","sql":"CREATE POLICY \"Users can view members of organizations they belong to\" ON organization_members FOR SELECT USING (EXISTS (SELECT 1 FROM organization_members om WHERE om.organization_id = organization_members.organization_id AND om.user_id = auth.uid()));","why_bad":"Self-references organization_members inside its own policy ‚Üí recursive policy evaluation."},{"name":"organization_members_own_only","for":"SELECT","sql":"CREATE POLICY \"organization_members_own_only\" ON organization_members FOR SELECT USING (user_id = auth.uid());","why_bad":"Duplicates the 'own memberships' intent; overlapping SELECT policies make behavior harder to reason about."},{"name":"Service role can manage all memberships","for":"ALL","sql":"CREATE POLICY \"Service role can manage all memberships\" ON organization_members FOR ALL USING (auth.role() = 'service_role');","why_bad":"Not inherently bad; keep as explicit server-side override."}],"related_issues":[{"table":"public.organizations","policy":"organizations_allow_all","sql":"CREATE POLICY \"organizations_allow_all\" ON organizations FOR ALL USING (true);","why_bad":"Overrides restrictive SELECT policy ('Users can view organizations they are members of'). Enables broad unintended access."}],"good_pattern":{"title":"Consolidated, non-recursive RLS using SECURITY DEFINER helper","helper_fn_sql":"CREATE OR REPLACE FUNCTION public.is_member_of(org_id uuid, uid uuid)\nRETURNS boolean\nLANGUAGE sql\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.organization_members m\n    WHERE m.organization_id = org_id\n      AND m.user_id = uid\n  );\n$$;","consolidated_policy_sql":"ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;\nDROP POLICY IF EXISTS \"Users can view members of organizations they belong to\" ON public.organization_members;\nDROP POLICY IF EXISTS \"organization_members_own_only\" ON public.organization_members;\nDROP POLICY IF EXISTS \"Service role can manage all memberships\" ON public.organization_members;\nCREATE POLICY \"service role can manage all\" ON public.organization_members FOR ALL USING (auth.role() = 'service_role');\nCREATE POLICY \"org_members_read\" ON public.organization_members FOR SELECT USING (auth.role() = 'service_role' OR user_id = auth.uid() OR public.is_member_of(organization_id, auth.uid()));","organizations_fix_sql":"DROP POLICY IF EXISTS \"organizations_allow_all\" ON public.organizations;\nCREATE POLICY \"orgs_read_members_only\" ON public.organizations FOR SELECT USING (public.is_member_of(id, auth.uid()) OR auth.role() = 'service_role');","why_good":["Avoids self-referencing the protected table inside its own policy.","One SELECT policy ‚Üí predictable behavior and easier audits.","SERVICE ROLE carve-out remains explicit.","Organizations visibility aligns with membership helper; no 'allow all'."]},"migration_steps":["1) Create SECURITY DEFINER function public.is_member_of(org_id, uid) owned by the table owner.","2) DROP the self-referencing and duplicate SELECT policies on organization_members.","3) (Re)create a single consolidated SELECT policy using is_member_of(...) + keep service-role policy.","4) DROP 'organizations_allow_all' and replace with a membership-based SELECT policy.","5) Verify with canary queries (see below)."],"canary_tests":[{"name":"Self user can select only their own memberships","sql":"SET ROLE authenticated; SELECT count(*) FROM public.organization_members WHERE user_id = auth.uid();","expect":"succeeds; returns only rows for current user"},{"name":"Member can see other members of same org (via join, not recursion)","sql":"SELECT count(*) FROM public.organization_members m2 WHERE m2.organization_id IN (SELECT organization_id FROM public.organization_members WHERE user_id = auth.uid());","expect":"succeeds; no recursion error"},{"name":"Non-member cannot see other org memberships","sql":"SELECT * FROM public.organization_members WHERE organization_id = 'some_other_org';","expect":"returns zero rows"},{"name":"Organizations SELECT restricted","sql":"SELECT * FROM public.organizations;","expect":"returns only organizations where user is a member (unless service_role)"}],"lint_rules":[{"id":"rls-self-reference","description":"Detect policies that SELECT from the same table they protect.","pattern":"USING contains subquery referencing current table name","severity":"error","suggestion":"Move membership logic into a SECURITY DEFINER helper and call it in the policy."},{"id":"rls-duplicate-select","description":"Multiple SELECT policies with overlapping predicates on same table.","severity":"warn","suggestion":"Consolidate into a single SELECT policy with clear OR conditions."},{"id":"rls-allow-all-shadow","description":"Detect FOR ALL/SELECT USING(true) on sensitive tables that shadow restrictive policies.","severity":"error","suggestion":"Remove allow-all or guard behind service_role only."}],"artifacts":{"sql_apply_ordered":["<<helper_fn_sql>>","<<consolidated_policy_sql>>","<<organizations_fix_sql>>"],"notes":"Ensure the helper function owner is a role exempt from RLS (table owner). In Supabase, functions run with their owner privileges when SECURITY DEFINER is set, avoiding recursion."}}
{"id":"supabase/auth/magic-link/timing-issue@2025-01-27","provider":"supabase","doc_type":"blueprint-fix","tags":["supabase","auth","magic-link","nextjs","timing","session","middleware","redirect"],"summary":{"embedding_text":"Fix magic link authentication timing issue where immediate redirect causes session not to be established before middleware check. Use auth state change listener to wait for SIGNED_IN event before redirecting to dashboard. Critical: Supabase magic link auth is asynchronous - session establishment takes time."},"context":{"framework":"Next.js App Router with Supabase SSR","version":"Next.js 15, Supabase Auth v2","symptoms":["Magic link clicked but user shows as 'Not authenticated' in middleware","Immediate redirect to dashboard fails with session not established","Works when manually accessing dashboard after magic link","Middleware logs show: 'User: Not authenticated' then later 'User: email@domain.com'","Browser console shows: 'Auth confirm params: { code: \"...\", tokenHash: null, type: null }'"],"observed_error":"AuthApiError: invalid request: both auth code and code verifier should be non-empty","calling_code_excerpt":"// In /auth/confirm page\nif (code) {\n  router.push('/dashboard'); // ‚ùå Called immediately\n}","debugging_logs":{"middleware_logs":"üîê Middleware - Path: /auth/confirm\nüë§ User: Not authenticated\nüîê Middleware - Path: /dashboard\nüë§ User: Not authenticated\nüö´ Redirecting to login - no user on protected route: /dashboard","browser_console":"üîó Auth confirm params: { code: \"55166e45-81f6-4d62-a98b-822565069d6f\", tokenHash: null, type: null, errorParam: null, errorDescription: null }","success_logs":"üîê Middleware - Path: /dashboard\nüë§ User: simon@hydraoss.io (f1ceefc0-bd0b-49ca-9101-86b4bcff0d4a)\nüìä User metadata: { email: 'simon@hydraoss.io', email_verified: true, ... }"},"root_cause":"Magic link authentication in Supabase is asynchronous. When the magic link is clicked, the session is established server-side, but the client-side JavaScript needs to wait for the auth state change event to know when the session is ready. Immediate redirects happen before the session is established."},"bad_patterns":[{"name":"Immediate redirect after magic link","code":"//  BAD: Immediate redirect\nif (code) {\n  console.log('üîê Magic link detected, redirecting to dashboard...');\n  router.push('/dashboard'); // Session not established yet\n}","why_bad":"Magic link authentication is asynchronous - session takes time to establish. This causes the middleware to see 'Not authenticated' and redirect to login."},{"name":"PKCE code exchange without verifier","code":"// BAD: Missing code verifier\nconst { data, error } = await supabase.auth.exchangeCodeForSession(code);\n// Fails with: 'both auth code and code verifier should be non-empty'","why_bad":"PKCE flow requires code verifier parameter, but magic links don't provide one in the URL."},{"name":"Wrong session structure access","code":"// ‚ùå BAD: Wrong session structure\nif (sessionData.user) { // Should be sessionData.session.user\n  router.push('/dashboard');\n}","why_bad":"Supabase session object has nested structure: sessionData.session.user, not sessionData.user directly."}],"good_pattern":{"title":"Auth state change listener with proper session handling","listener_code":"// ‚úÖ GOOD: Listen for auth state changes\nif (code) {\n  console.log('üîê Magic link detected, setting up auth listener...');\n  \n  // Listen for auth state changes\n  const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {\n    console.log('üîê Auth state change:', event, session?.user?.email);\n    \n    if (event === 'SIGNED_IN' && session?.user) {\n      console.log('‚úÖ User signed in:', session.user.email);\n      router.push('/dashboard');\n      subscription.unsubscribe();\n    }\n  });\n  \n  // Also check for existing session\n  const { data: sessionData } = await supabase.auth.getSession();\n  if (sessionData.session && sessionData.session.user) {\n    console.log('‚úÖ Session already exists:', sessionData.session.user.email);\n    router.push('/dashboard');\n    subscription.unsubscribe();\n  }\n}","session_check_code":"// ‚úÖ GOOD: Check existing session with correct structure\nconst { data: sessionData } = await supabase.auth.getSession();\nif (sessionData.session && sessionData.session.user) {\n  console.log('‚úÖ Session already exists:', sessionData.session.user.email);\n  router.push('/dashboard');\n  subscription.unsubscribe();\n}","why_good":["Waits for actual authentication event (SIGNED_IN)","Handles both new and existing sessions","Proper cleanup with unsubscribe to prevent memory leaks","No PKCE complications - uses auth state listener instead","Correct session structure: sessionData.session.user"]},"migration_steps":["1) Replace immediate redirect with auth state listener","2) Add session check for already authenticated users","3) Use proper session structure (sessionData.session.user not sessionData.user)","4) Clean up listener subscription when done","5) Test magic link flow end-to-end","6) Add console logging to debug auth state changes","7) Verify middleware logs show authenticated user"],"canary_tests":[{"name":"Magic link establishes session","test":"Click magic link and check middleware logs","expect":"User shows as authenticated in middleware: 'üë§ User: email@domain.com (uuid)'"},{"name":"Auth state listener fires","test":"Check browser console for SIGNED_IN event","expect":"Console shows 'üîê Auth state change: SIGNED_IN email@domain.com'"},{"name":"Redirect happens after session","test":"Verify redirect to dashboard only after authentication","expect":"No intermediate redirect to login page"},{"name":"Session structure is correct","test":"Check that sessionData.session.user exists","expect":"No 'user' property in session type errors"}],"lint_rules":[{"id":"auth-immediate-redirect","description":"Avoid immediate redirects after auth actions that are asynchronous.","pattern":"router.push() called immediately after auth method","severity":"error","suggestion":"Use auth state change listener or add delay"},{"id":"auth-session-structure","description":"Use correct session object structure in Supabase.","pattern":"sessionData.user instead of sessionData.session.user","severity":"error","suggestion":"Access user via sessionData.session.user"},{"id":"auth-listener-cleanup","description":"Always unsubscribe from auth state change listeners.","pattern":"onAuthStateChange without unsubscribe","severity":"warn","suggestion":"Call subscription.unsubscribe() when done"},{"id":"auth-magic-link-timing","description":"Magic link authentication is asynchronous - wait for SIGNED_IN event.","pattern":"Magic link redirect without auth state listener","severity":"error","suggestion":"Use onAuthStateChange listener to wait for SIGNED_IN event"}],"artifacts":{"code_apply_ordered":["<<listener_code>>","<<session_check_code>>"],"notes":"Magic link authentication in Supabase is asynchronous. The session is established server-side when the link is clicked, but the client needs to wait for the auth state change event to know when it's ready. The key insight is that middleware runs immediately but the session takes time to establish, causing the 'Not authenticated' ‚Üí redirect to login ‚Üí then later 'authenticated' pattern."}}
{"id":"supabase/auth/oauth/database-error-saving-user@2025-01-27","provider":"supabase","doc_type":"blueprint-fix","tags":["supabase","auth","oauth","google","database","rls","profiles","triggers"],"summary":{"embedding_text":"Fix Google OAuth authentication error where user creation succeeds but database profile creation fails due to missing profiles table and RLS policies. Create profiles table with proper RLS policies and automatic profile creation trigger for new OAuth users."},"context":{"framework":"Next.js App Router with Supabase SSR","version":"Next.js 15, Supabase Auth v2","symptoms":["Google OAuth redirects successfully but shows 'Authentication Error'","Error message: 'Database error saving new user'","OAuth flow works with some emails but fails with others","User appears in auth.users but no profile record created"],"observed_error":"Authentication Error: There was an error with your authentication. Please try again. Database error saving new user","calling_code_excerpt":"// OAuth callback handling\nconst { data, error } = await supabase.auth.exchangeCodeForSession(code);\n// Fails during profile creation, not during OAuth exchange","debugging_logs":{"oauth_success":"Google OAuth redirects to /auth/callback successfully","database_failure":"Error occurs during profile record creation","missing_table":"profiles table does not exist in database","rls_blocking":"No RLS policies allow profile creation for new users"},"root_cause":"Supabase OAuth creates auth.users record but fails to create corresponding profile record due to missing profiles table and RLS policies that block profile creation for new users."},"bad_patterns":[{"name":"Missing profiles table","code":"// BAD: No profiles table exists\n// OAuth creates auth.users but no profile record\n// Results in incomplete user data","why_bad":"OAuth users have no profile record, breaking app functionality that depends on profiles table."},{"name":"No RLS policies on profiles","code":"// BAD: profiles table has RLS enabled but no policies\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n-- No policies created\n-- Results in: 'permission denied for table profiles'","why_bad":"RLS blocks all access to profiles table, preventing new user profile creation."},{"name":"Manual profile creation","code":"// BAD: Relying on client-side profile creation\nuseEffect(() => {\n  if (user && !profile) {\n    createProfile(); // Can fail due to RLS\n  }\n}, [user]);","why_bad":"Client-side profile creation is unreliable and can fail due to RLS policies or network issues."}],"good_pattern":{"title":"Automatic profile creation with proper RLS policies","profiles_table_sql":"CREATE TABLE IF NOT EXISTS profiles (\n  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,\n  full_name TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;","rls_policies_sql":"CREATE POLICY \"Users can view own profile\" ON profiles FOR SELECT USING (auth.uid() = id);\nCREATE POLICY \"Users can insert own profile\" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);\nCREATE POLICY \"Users can update own profile\" ON profiles FOR UPDATE USING (auth.uid() = id);","trigger_function_sql":"CREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO public.profiles (id, full_name)\n  VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;","trigger_sql":"DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();","why_good":["Automatic profile creation on user signup","Proper RLS policies allow users to manage their own profiles","SECURITY DEFINER function bypasses RLS for profile creation","Works for all OAuth providers (Google, GitHub, etc.)","No client-side profile creation needed"]},"migration_steps":["1) Create profiles table with proper structure","2) Enable RLS and create policies for user profile management","3) Create SECURITY DEFINER function for automatic profile creation","4) Create trigger to fire on new user signup","5) Test OAuth flow with new users","6) Verify profile records are created automatically"],"canary_tests":[{"name":"OAuth user gets profile","test":"Sign up with Google OAuth and check profiles table","expect":"Profile record created automatically with user ID and name"},{"name":"RLS policies work","test":"Try to access other user's profile","expect":"Only own profile accessible, others blocked"},{"name":"Profile updates work","test":"Update own profile information","expect":"Profile updates successfully"},{"name":"User deletion cascades","test":"Delete user from auth.users","expect":"Profile record deleted automatically due to CASCADE"}],"lint_rules":[{"id":"oauth-missing-profiles","description":"OAuth apps should have profiles table for user data.","pattern":"OAuth authentication without profiles table","severity":"error","suggestion":"Create profiles table with proper RLS policies"},{"id":"rls-no-policies","description":"Tables with RLS enabled must have policies.","pattern":"ALTER TABLE ENABLE ROW LEVEL SECURITY without policies","severity":"error","suggestion":"Create appropriate RLS policies for table access"},{"id":"oauth-manual-profiles","description":"Avoid manual client-side profile creation for OAuth.","pattern":"Client-side profile creation after OAuth","severity":"warn","suggestion":"Use database triggers for automatic profile creation"},{"id":"oauth-trigger-missing","description":"OAuth apps should have user creation triggers.","pattern":"OAuth without profile creation trigger","severity":"error","suggestion":"Create trigger to automatically create profiles for new users"}],"artifacts":{"sql_apply_ordered":["<<profiles_table_sql>>","<<rls_policies_sql>>","<<trigger_function_sql>>","<<trigger_sql>>"],"notes":"OAuth authentication creates auth.users records but apps typically need additional user data in a profiles table. The trigger approach ensures profiles are created automatically without relying on client-side code, which can fail due to RLS policies or network issues."}}
{"id":"supabase/auth/oauth/multi-provider-setup@2025-01-27","provider":"supabase","doc_type":"blueprint-fix","tags":["supabase","auth","oauth","github","google","multi-provider","login","ui"],"summary":{"embedding_text":"Add multiple OAuth providers (Google and GitHub) to login page with consistent UI patterns and proper error handling. Implement reusable OAuth handler pattern for easy provider addition and maintain consistent user experience across all OAuth providers."},"context":{"framework":"Next.js App Router with Supabase SSR","version":"Next.js 15, Supabase Auth v2","symptoms":["Only single OAuth provider available","Users prefer different OAuth providers","Inconsistent OAuth implementation patterns","Hard to add new OAuth providers"],"observed_error":"No specific error - enhancement request","calling_code_excerpt":"// Single OAuth provider implementation\nconst handleGoogleLogin = async () => {\n  const { error } = await supabase.auth.signInWithOAuth({\n    provider: 'google',\n    options: { redirectTo: `${window.location.origin}/auth/callback` }\n  });\n};","debugging_logs":{"single_provider":"Only Google OAuth available","user_preference":"Users request GitHub OAuth option","ui_consistency":"OAuth buttons need consistent styling"},"root_cause":"Login page only implements single OAuth provider (Google) without pattern for adding additional providers like GitHub, leading to limited authentication options for users."},"bad_patterns":[{"name":"Single OAuth provider","code":"// BAD: Only one OAuth provider\nconst handleGoogleLogin = async () => {\n  // Google OAuth only\n};\n// No GitHub or other providers","why_bad":"Limits user choice and authentication options. Users may prefer different OAuth providers."},{"name":"Inconsistent OAuth handlers","code":"// BAD: Different patterns for each provider\nconst handleGoogle = () => { /* Google logic */ };\nconst handleGitHub = () => { /* Different GitHub logic */ };","why_bad":"Inconsistent implementation makes maintenance difficult and error-prone."},{"name":"Hardcoded provider logic","code":"// BAD: Provider-specific logic scattered\nif (provider === 'google') {\n  // Google-specific code\n} else if (provider === 'github') {\n  // GitHub-specific code\n}","why_bad":"Hard to maintain and extend with new providers."}],"good_pattern":{"title":"Reusable OAuth handler with consistent UI patterns","oauth_handler_code":"const handleOAuthLogin = async (provider: 'google' | 'github') => {\n  setLoading(true);\n  setMessage('');\n\n  try {\n    const { error } = await supabase.auth.signInWithOAuth({\n      provider,\n      options: {\n        redirectTo: `${window.location.origin}/auth/callback`,\n      },\n    });\n\n    if (error) {\n      setMessage(error.message);\n    }\n  } catch (error) {\n    setMessage('An error occurred. Please try again.');\n  } finally {\n    setLoading(false);\n  }\n};","ui_buttons_code":"<div className=\"mt-6 space-y-3\">\n  <button\n    type=\"button\"\n    onClick={() => handleOAuthLogin('google')}\n    disabled={loading}\n    className=\"w-full inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50\"\n  >\n    <GoogleIcon className=\"w-5 h-5\" />\n    <span className=\"ml-2\">Sign in with Google</span>\n  </button>\n\n  <button\n    type=\"button\"\n    onClick={() => handleOAuthLogin('github')}\n    disabled={loading}\n    className=\"w-full inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-500 hover:bg-gray-50 disabled:opacity-50\"\n  >\n    <GitHubIcon className=\"w-5 h-5\" />\n    <span className=\"ml-2\">Sign in with GitHub</span>\n  </button>\n</div>","provider_config_code":"const oauthProviders = [\n  {\n    id: 'google',\n    name: 'Google',\n    icon: GoogleIcon,\n    color: 'text-red-500'\n  },\n  {\n    id: 'github',\n    name: 'GitHub',\n    icon: GitHubIcon,\n    color: 'text-gray-700'\n  }\n];","why_good":["Single reusable handler for all OAuth providers","Consistent error handling and loading states","Easy to add new providers by updating config","Consistent UI patterns across all providers","Type-safe provider parameter"]},"migration_steps":["1) Create reusable OAuth handler function","2) Add GitHub OAuth provider configuration","3) Update UI to support multiple OAuth buttons","4) Add proper GitHub icon and styling","5) Test both Google and GitHub OAuth flows","6) Verify consistent error handling","7) Document pattern for adding new providers"],"canary_tests":[{"name":"Google OAuth works","test":"Click Google sign-in button and complete OAuth flow","expect":"User successfully authenticated with Google account"},{"name":"GitHub OAuth works","test":"Click GitHub sign-in button and complete OAuth flow","expect":"User successfully authenticated with GitHub account"},{"name":"Consistent error handling","test":"Test OAuth with invalid credentials","expect":"Same error message format for both providers"},{"name":"Loading states work","test":"Click OAuth button and check loading state","expect":"Button shows loading state and disables interaction"},{"name":"Profile creation works","test":"Sign up with new OAuth account","expect":"Profile record created automatically via trigger"}],"lint_rules":[{"id":"oauth-single-provider","description":"Login pages should support multiple OAuth providers.","pattern":"Only one OAuth provider implemented","severity":"warn","suggestion":"Add support for multiple OAuth providers (Google, GitHub, etc.)"},{"id":"oauth-inconsistent-handlers","description":"OAuth handlers should use consistent patterns.","pattern":"Different OAuth handler implementations","severity":"warn","suggestion":"Create reusable OAuth handler function"},{"id":"oauth-missing-providers","description":"Common OAuth providers should be available.","pattern":"Missing GitHub, Google, or other common providers","severity":"info","suggestion":"Add support for GitHub and other popular OAuth providers"},{"id":"oauth-ui-consistency","description":"OAuth buttons should have consistent styling.","pattern":"Inconsistent OAuth button styling","severity":"warn","suggestion":"Use consistent CSS classes and layout for all OAuth buttons"}],"artifacts":{"code_apply_ordered":["<<oauth_handler_code>>","<<ui_buttons_code>>","<<provider_config_code>>"],"notes":"Multi-provider OAuth setup improves user experience by offering authentication options. The reusable handler pattern makes it easy to add new providers without duplicating code. Consistent UI patterns ensure professional appearance across all OAuth options."}}